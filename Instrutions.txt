Instrutions:
This project is used to manage contents from multiple Organisations.
Using get_db_for_organization and get_db_for_user function to ensure that each organization's data 
is stored in and retrieved from its respective database.
Example, if a user of organisation "GIES" creates a plan, it should go to "giesdb" database, 
and if a user of organisation "GIGMEG" creates a plan, it should go to "gigmegdb" database.
Modify the following codes to provide a "rubust" and "clean" solution based on the models and instructions mentioned in the previous conversations.

Note that, 
1. all models are associated with an organasation either directly or indirectly. 
2. some models may depend on others to work well.
3. without using routers
4. all views must manupulate the contents of the right organasation the request is going to or coming from.


#   utils.py file
def get_db_for_organization(organization):
    if organization:
        return f"{organization.slug}_db"
    return 'default'

def get_db_for_user(user):
    if user.is_authenticated and hasattr(user, 'organization'):
        return get_db_for_organization(user.organization)
    return 'default'


#   mixins.py file
from django.utils.functional import cached_property
from .utils import get_db_for_user


class ValidateOrgMixin(object):
    """
    - implements ``_validate_org_relation`` method
    """

    def _validate_org_relation(self, rel, field_error='organization'):
        """
        if the relation is owned by a specific organization
        this object must be related to the same organization
        """
        # avoid exceptions caused by the relation not being set
        if not hasattr(self, rel):
            return
        rel = getattr(self, rel)
        if (
            rel
            and rel.organization_id
            and str(self.organization_id) != str(rel.organization_id)
        ):
            message = _(
                'Please ensure that the organization of this {object_label} '
                'and the organization of the related {related_object_label} match.'
            )
            message = message.format(
                object_label=self._meta.verbose_name,
                related_object_label=rel._meta.verbose_name,
            )
            raise ValidationError({field_error: message})

    def _validate_org_reverse_relation(self, rel_name, field_error='organization'):
        """
        prevents changing organization for existing objects
        which have relations specified by ``rel_name`` pointing to them,
        in order to prevent inconsistencies
        (relations belonging to different organizations)
        """
        # do nothing on new objects, because they
        # cannot have relations pointing to them
        if self._state.adding:
            return
        old_self = self.__class__.objects.get(pk=self.pk)
        old_org = old_self.organization
        # org hasn't been changed, everything ok
        if old_org == self.organization:
            return
        rel = getattr(self, rel_name)
        count = rel.count()
        if count:
            rel_meta = rel.model._meta
            related_label = (
                rel_meta.verbose_name if count == 1 else rel_meta.verbose_name_plural
            )
            verb = _('is') if count == 1 else _('are')
            message = _(
                'The organization of this {object_label} cannot be changed '
                'because {0} {related_object_label} {verb} still '
                'related to it'.format(
                    count,
                    object_label=self._meta.verbose_name,
                    related_object_label=related_label,
                    verb=verb,
                )
            )
            raise ValidationError({field_error: message})


class OrgMixin(ValidateOrgMixin, models.Model):
    """
    - adds a ``ForeignKey`` field to the ``Organization`` model
      (the relation cannot be NULL)
    - implements ``_validate_org_relation`` method
    """

    organization = models.ForeignKey(
        get_model_name('openwisp_users', 'Organization'),
        verbose_name=_('organization'),
        on_delete=models.CASCADE,
    )

    class Meta:
        abstract = True


class OrganizationDbMixin:
    @cached_property
    def db(self):
        user = self.request.user
        if user.is_authenticated:
            return get_db_for_user(user)
        return 'default'

    def get_queryset(self):
        return super().get_queryset().using(self.db)
    
    def get_object(self, queryset=None):
        if queryset is None:
            queryset = self.get_queryset()
        return super().get_object(queryset=queryset)


#   db.py file
import environ
from pathlib import Path

BASE_DIR = Path(__file__).resolve(strict=True).parent

env = environ.Env()
env.read_env() # read the .env file
# environ.Env.read_env() # read the .env file

# DATABASES for different organisations
DATABASES = {
    'default': {
        'ENGINE': env('POSTGRES_ENGINE'),
        'NAME': env('DEFAULT_DB_NAME'),
        'USER': env('DEFAULT_DB_USER'),
        'PASSWORD': env('DEFAULT_DB_PASSWORD'),
        'HOST': env('DEFAULT_DB_HOST'),
        'PORT': env('DEFAULT_DB_PORT'),
    },
    'gies': {
        'ENGINE': env('POSTGRES_ENGINE'),
        'NAME': env('GIES_DB_NAME'),
        'USER': env('GIES_DB_USER'),
        'PASSWORD': env('GIES_DB_PASSWORD'),
        'HOST': env('GIES_DB_HOST'),
        'PORT': env('GIES_DB_PORT'),
    },
    'gigmeg': {
        'ENGINE': env('POSTGRES_ENGINE'),
        'NAME': env('GIGMEG_DB_NAME'),
        'USER': env('GIGMEG_DB_USER'),
        'PASSWORD': env('GIGMEG_DB_PASSWORD'),
        'HOST': env('GIGMEG_DB_HOST'),
        'PORT': env('GIGMEG_DB_PORT'),
    },
}


#   views.py file
class AccountActivationView(LoginRequired, TemplateView):
    template_name = "plans/account_activation.html"

    def get_context_data(self, **kwargs):
        if (
            self.request.user.userplan.active is True
            or self.request.user.userplan.is_expired()
        ):
            raise Http404()

        context = super(AccountActivationView, self).get_context_data(**kwargs)
        errors = self.request.user.userplan.clean_activation()

        if errors["required_to_activate"]:
            context["SUCCESSFUL"] = False
        else:
            context["SUCCESSFUL"] = True
            messages.success(self.request, _("Your account is now active"))

        for error in errors["required_to_activate"]:
            messages.error(self.request, error)
        for error in errors["other"]:
            messages.warning(self.request, error)

        return context


class PlanTableMixin(object):
    def get_plan_table(self, plan_list):
        """
        This method return a list in following order:
        [
            ( Quota1, [ Plan1Quota1, Plan2Quota1, ... , PlanNQuota1] ),
            ( Quota2, [ Plan1Quota2, Plan2Quota2, ... , PlanNQuota2] ),
            ...
            ( QuotaM, [ Plan1QuotaM, Plan2QuotaM, ... , PlanNQuotaM] ),
        ]

        This can be very easily printed as an HTML table element with quotas by row.

        Quotas are calculated based on ``plan_list``. These are all available quotas that are
        used by given plans. If any ``Plan`` does not have any of ``PlanQuota`` then value ``None``
        will be propagated to the data structure.

        """

        # Retrieve all quotas that are used by any ``Plan`` in ``plan_list``
        quota_list = (
            Quota.objects.all().filter(planquota__plan__in=plan_list).distinct()
        )

        # Create random access dict that for every ``Plan`` map ``Quota`` -> ``PlanQuota``
        plan_quotas_dic = {}
        for plan in plan_list:
            plan_quotas_dic[plan] = {}
            for plan_quota in plan.planquota_set.all():
                plan_quotas_dic[plan][plan_quota.quota] = plan_quota

        # Generate data structure described in method docstring, propagate ``None`` whenever
        # ``PlanQuota`` is not available for given ``Plan`` and ``Quota``
        return map(
            lambda quota: (
                quota,
                map(lambda plan: plan_quotas_dic[plan].get(quota, None), plan_list),
            ),
            quota_list,
        )


class PlanTableViewBase(PlanTableMixin, ListView):
    model = Plan
    context_object_name = "plan_list"

    def get_queryset(self):
        queryset = (
            super(PlanTableViewBase, self)
            .get_queryset()
            .prefetch_related("planpricing_set__pricing", "planquota_set__quota")
        )
        if self.request.user.is_authenticated:
            queryset = queryset.filter(
                Q(available=True, visible=True)
                & (Q(customized=self.request.user) | Q(customized__isnull=True))
            )
        else:
            queryset = queryset.filter(
                Q(available=True, visible=True) & Q(customized__isnull=True)
            )
        return queryset

    def get_context_data(self, **kwargs):
        context = super(PlanTableViewBase, self).get_context_data(**kwargs)

        if self.request.user.is_authenticated:
            try:
                self.userplan = UserPlan.objects.select_related("plan").get(
                    user=self.request.user
                )
            except UserPlan.DoesNotExist:
                self.userplan = None

            context["userplan"] = self.userplan

            try:
                context["current_userplan_index"] = list(self.object_list).index(
                    self.userplan.plan
                )
            except (ValueError, AttributeError):
                pass

        context["plan_table"] = self.get_plan_table(self.object_list)
        context["CURRENCY"] = settings.PLANS_CURRENCY

        return context


class CurrentPlanView(LoginRequired, PlanTableViewBase):
    template_name = "plans/current.html"

    def get_queryset(self):
        return Plan.objects.filter(userplan__user=self.request.user).prefetch_related(
            "planpricing_set__pricing", "planquota_set__quota"
        )


class UpgradePlanView(LoginRequired, PlanTableViewBase):
    template_name = "plans/upgrade.html"


class PricingView(PlanTableViewBase):
    template_name = "plans/pricing.html"


class ChangePlanView(LoginRequired, View):
    """
    A view for instant changing user plan when it does not require additional payment.
    Plan can be changed without payment when:
    * user can enable this plan (it is available & visible and if it is customized it is for him,
    * plan is different from the current one that user have,
    * within current change plan policy this does not require any additional payment (None)

    It always redirects to ``upgrade_plan`` url as this is a potential only one place from
    where change plan could be invoked.
    """

    def get(self, request, *args, **kwargs):
        return HttpResponseRedirect(reverse("upgrade_plan"))

    def post(self, request, *args, **kwargs):
        plan = get_object_or_404(
            Plan,
            Q(pk=kwargs["pk"])
            & Q(available=True, visible=True)
            & (Q(customized=request.user) | Q(customized__isnull=True)),
        )
        if request.user.userplan.plan != plan:
            policy = import_name(
                getattr(
                    settings,
                    "PLANS_CHANGE_POLICY",
                    "plans.plan_change.StandardPlanChangePolicy",
                )
            )()

            period = request.user.userplan.days_left()
            price = policy.get_change_price(request.user.userplan.plan, plan, period)

            if price is None:
                request.user.userplan.extend_account(plan, None)
                messages.success(request, _("Your plan has been successfully changed"))
            else:
                return HttpResponseForbidden()
        return HttpResponseRedirect(reverse("upgrade_plan"))


class CreateOrderView(LoginRequired, CreateView):
    template_name = "plans/create_order.html"
    form_class = CreateOrderForm

    def recalculate(self, amount, billing_info):
        """
        Calculates and return pre-filled Order
        """
        order = Order(pk=-1)
        order.recalculate(amount, billing_info, self.request)
        return order

    def validate_plan(self, plan):
        validation_errors = plan_validation(self.request.user, plan)
        if validation_errors["required_to_activate"] or validation_errors["other"]:
            messages.error(
                self.request,
                _(
                    "The selected plan is insufficient for your account. "
                    "Your account will not be activated or will not work fully after completing this order."
                    "<br><br>Following limits will be exceeded: <ul><li>%(reasons)s</ul>"
                )
                % {
                    "reasons": "<li>".join(
                        chain(
                            validation_errors["required_to_activate"],
                            validation_errors["other"],
                        )
                    ),
                },
            )

    def get_all_context(self):
        """
        Retrieves Plan and Pricing for current order creation
        """
        self.plan_pricing = get_object_or_404(
            PlanPricing.objects.all().select_related("plan", "pricing"),
            Q(pk=self.kwargs["pk"])
            & Q(plan__available=True)
            & (
                Q(plan__customized=self.request.user) | Q(plan__customized__isnull=True)
            ),
        )

        # User is not allowed to create new order for Plan when he has different Plan
        # unless it's a free plan. Otherwise, the should use Plan Change View for this
        # kind of action
        if (
            not self.request.user.userplan.is_expired()
            and not self.request.user.userplan.plan.is_free()
            and self.request.user.userplan.plan != self.plan_pricing.plan
        ):
            raise Http404

        self.plan = self.plan_pricing.plan
        self.pricing = self.plan_pricing.pricing

    def get_billing_info(self):
        try:
            return self.request.user.billinginfo
        except BillingInfo.DoesNotExist:
            return None

    def get_price(self):
        return self.plan_pricing.price

    def get_context_data(self, **kwargs):
        context = super(CreateOrderView, self).get_context_data(**kwargs)
        self.get_all_context()
        context["billing_info"] = self.get_billing_info()

        order = self.recalculate(
            self.get_price() or Decimal("0.0"), context["billing_info"]
        )
        order.plan = self.plan_pricing.plan
        order.pricing = self.plan_pricing.pricing
        order.currency = get_currency()
        order.user = self.request.user
        context["object"] = order

        self.validate_plan(order.plan)
        return context

    def form_valid(self, form):
        self.get_all_context()
        order = self.recalculate(
            self.get_price() or Decimal("0.0"), self.get_billing_info()
        )

        self.object = form.save(commit=False)
        self.object.user = self.request.user
        self.object.plan = self.plan
        self.object.pricing = self.pricing
        self.object.amount = order.amount
        self.object.tax = order.tax
        self.object.currency = order.currency
        self.object.save()
        order_started.send(sender=self.object)
        return super(ModelFormMixin, self).form_valid(form)


class CreateOrderPlanChangeView(CreateOrderView):
    template_name = "plans/create_order.html"
    form_class = CreateOrderForm

    def get_all_context(self):
        self.plan = get_object_or_404(
            Plan,
            Q(pk=self.kwargs["pk"])
            & Q(available=True, visible=True)
            & (Q(customized=self.request.user) | Q(customized__isnull=True)),
        )
        self.pricing = None

    def get_policy(self):
        policy_class = getattr(
            settings,
            "PLANS_CHANGE_POLICY",
            "plans.plan_change.StandardPlanChangePolicy",
        )
        return import_name(policy_class)()

    def get_price(self):
        policy = self.get_policy()
        userplan = self.request.user.userplan

        if userplan.expire is not None:
            period = self.request.user.userplan.days_left()
        else:
            # Use the default period of the new plan
            period = 30

        return policy.get_change_price(
            self.request.user.userplan.plan, self.plan, period
        )

    def get_context_data(self, **kwargs):
        context = super(CreateOrderView, self).get_context_data(**kwargs)
        self.get_all_context()

        price = self.get_price()
        context["plan"] = self.plan
        context["billing_info"] = self.get_billing_info()
        if price is None:
            context["FREE_ORDER"] = True
            price = 0
        order = self.recalculate(price, context["billing_info"])
        order.pricing = None
        order.plan = self.plan
        order.user = self.request.user
        context["billing_info"] = context["billing_info"]
        context["object"] = order
        self.validate_plan(order.plan)
        return context


class OrderView(LoginRequired, DetailView):
    model = Order

    def get_queryset(self):
        return (
            super(OrderView, self)
            .get_queryset()
            .filter(user=self.request.user)
            .select_related(
                "plan",
                "pricing",
            )
        )


class OrderListView(LoginRequired, ListView):
    model = Order
    paginate_by = 10

    def get_context_data(self, **kwargs):
        context = super(OrderListView, self).get_context_data(**kwargs)
        self.CURRENCY = getattr(settings, "PLANS_CURRENCY", None)
        if len(self.CURRENCY) != 3:
            raise ImproperlyConfigured(
                "PLANS_CURRENCY should be configured as 3-letter currency code."
            )
        context["CURRENCY"] = self.CURRENCY
        return context

    def get_queryset(self):
        return (
            super(OrderListView, self)
            .get_queryset()
            .filter(user=self.request.user)
            .select_related(
                "plan",
                "pricing",
            )
        )


class OrderPaymentReturnView(LoginRequired, DetailView):
    """
    This view is a fallback from any payments processor. It allows just to set additional message
    context and redirect to Order view itself.
    """

    model = Order
    status = None

    def render_to_response(self, context, **response_kwargs):
        if self.status == "success":
            messages.success(
                self.request,
                _(
                    "Thank you for placing a payment. It will be processed as soon as possible."
                ),
            )
        elif self.status == "failure":
            messages.error(
                self.request,
                _(
                    "Payment was not completed correctly. Please repeat payment process."
                ),
            )

        return HttpResponseRedirect(self.object.get_absolute_url())

    def get_queryset(self):
        return (
            super(OrderPaymentReturnView, self)
            .get_queryset()
            .filter(user=self.request.user)
        )


class SuccessUrlMixin:
    def get_success_url(self):
        messages.success(self.request, _("Billing info has been updated successfuly."))
        return reverse("billing_info")


class CreateOrUpdateView(
    SingleObjectTemplateResponseMixin, ModelFormMixin, ProcessFormView
):
    def get(self, request, *args, **kwargs):
        self.object = self.get_object()
        return super().get(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):
        self.object = self.get_object()
        return super().post(request, *args, **kwargs)


class BillingInfoCreateOrUpdateView(
    NextUrlMixin, SuccessUrlMixin, LoginRequired, CreateOrUpdateView
):
    form_class = BillingInfoForm
    template_name = "plans/billing_info_create_or_update.html"

    def get_object(self):
        try:
            return self.request.user.billinginfo
        except (AttributeError, BillingInfo.DoesNotExist):
            return None

    def form_valid(self, form):
        form.instance.user = self.request.user
        return super().form_valid(form)

    def get_form_kwargs(self):
        kwargs = super().get_form_kwargs()
        kwargs.update(request=self.request)
        return kwargs


class RedirectToBilling(RedirectView):
    url = reverse_lazy("billing_info")
    permanent = False
    query_string = True

    def get_redirect_url(self, *args, **kwargs):
        warnings.warn(
            "This view URL is deprecated. Use plain billing_info instead.",
            DeprecationWarning,
        )
        return super().get_redirect_url(*args, **kwargs)


class BillingInfoDeleteView(LoginRequired, DeleteView):
    """
    Deletes billing data for user
    """

    template_name = "plans/billing_info_delete.html"

    def get_object(self):
        try:
            return self.request.user.billinginfo
        except BillingInfo.DoesNotExist:
            raise Http404

    def get_success_url(self):
        messages.success(self.request, _("Billing info has been deleted."))
        return reverse("billing_info")


class InvoiceDetailView(LoginRequired, DetailView):
    model = Invoice

    def get_template_names(self):
        return getattr(settings, "PLANS_INVOICE_TEMPLATE", "plans/invoices/PL_EN.html")

    def get_context_data(self, **kwargs):
        context = super(InvoiceDetailView, self).get_context_data(**kwargs)
        context["logo_url"] = getattr(settings, "PLANS_INVOICE_LOGO_URL", None)
        context["auto_print"] = True
        return context

    def get_queryset(self):
        if self.request.user.is_superuser:
            return super(InvoiceDetailView, self).get_queryset().select_related("order")
        else:
            return (
                super(InvoiceDetailView, self)
                .get_queryset()
                .filter(user=self.request.user)
                .select_related("order")
            )


class FakePaymentsView(LoginRequired, SingleObjectMixin, FormView):
    form_class = FakePaymentsForm
    model = Order
    template_name = "plans/fake_payments.html"

    def get_success_url(self):
        return self.object.get_absolute_url()

    def get_queryset(self):
        return (
            super(FakePaymentsView, self).get_queryset().filter(user=self.request.user)
        )

    def dispatch(self, *args, **kwargs):
        if not getattr(settings, "DEBUG", False):
            return HttpResponseForbidden("This view is accessible only in debug mode.")
        self.object = self.get_object()
        return super(FakePaymentsView, self).dispatch(*args, **kwargs)

    def form_valid(self, form):
        if int(form["status"].value()) == Order.STATUS.COMPLETED:
            self.object.complete_order()
            return HttpResponseRedirect(
                reverse("order_payment_success", kwargs={"pk": self.object.pk})
            )
        else:
            self.object.status = form["status"].value()
            self.object.save()
            return HttpResponseRedirect(
                reverse("order_payment_failure", kwargs={"pk": self.object.pk})
            )



# ---------------------------------------------------------- Plan payment

class PaymentDetailView(LoginRequiredMixin, View):
    login_url = reverse_lazy("auth_login")
    template_name = "plans_payments/payment.html"

    def get(self, request, *args, payment_id=None):
        payment = get_object_or_404(
            get_payment_model(), order__user=request.user, id=payment_id
        )
        try:
            form = payment.get_form(data=request.POST or None)
        except RedirectNeeded as redirect_to:
            payment.save()
            return redirect(str(redirect_to))
        return TemplateResponse(
            request, "plans_payments/payment.html", {"form": form, "payment": payment}
        )


def get_client_ip(request):
    return request.META.get("REMOTE_ADDR")


def create_payment_object(
    payment_variant, order, request=None, autorenewed_payment=False
):
    Payment = get_payment_model()
    if (
        hasattr(order.user.userplan, "recurring")
        and order.user.userplan.recurring.payment_provider != payment_variant
    ):
        order.user.userplan.recurring.delete()
    return Payment.objects.create(
        variant=payment_variant,
        order=order,
        description=f"{order.name} %s purchase",
        total=Decimal(order.total()),
        tax=Decimal(order.tax_total()),
        currency=order.currency,
        delivery=Decimal(0),
        billing_first_name=order.user.first_name,
        billing_last_name=order.user.last_name,
        billing_email=order.user.email or "",
        billing_address_1=order.user.billinginfo.street,
        # billing_address_2=order.user.billinginfo.zipcode,
        billing_city=order.user.billinginfo.city,
        billing_postcode=order.user.billinginfo.zipcode,
        billing_country_code=order.user.billinginfo.country,
        # billing_country_area=order.user.billinginfo.zipcode,
        customer_ip_address=get_client_ip(request) if request else "127.0.0.1",
        autorenewed_payment=autorenewed_payment,
    )


class CreatePaymentView(LoginRequiredMixin, View):
    login_url = reverse_lazy("auth_login")

    def get(self, request, *args, order_id=None, payment_variant=None):
        order = get_object_or_404(Order, pk=order_id, user=request.user)
        payment = create_payment_object(payment_variant, order, request)
        return redirect(reverse("payment_details", kwargs={"payment_id": payment.id}))

