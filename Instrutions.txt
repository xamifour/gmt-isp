Instrutions:
This project is used to manage contents from multiple Organisations.
Using get_db_for_organization and get_db_for_user function to ensure that each organization's data 
is stored in and retrieved from its respective database.
Example, if a user of organisation "GIES" creates a plan, it should go to "giesdb" database, 
and if a user of organisation "GIGMEG" creates a plan, it should go to "gigmegdb" database.
Modify the following codes to provide a "rubust" and "clean" solution based on the above instructions.

Note that, 
1. all models are associated with an organasation either directly or indirectly. 
2. some models may depend on others to work well.
3. without using routers


#   utils.py file
def get_db_for_organization(organization):
    if organization:
        return f"{organization.slug}_db"
    return 'default'

def get_db_for_user(user):
    if user.is_authenticated and hasattr(user, 'organization'):
        return get_db_for_organization(user.organization)
    return 'default'


#   mixins.py file
from django.utils.functional import cached_property
from .utils import get_db_for_user


class ValidateOrgMixin(object):
    """
    - implements ``_validate_org_relation`` method
    """

    def _validate_org_relation(self, rel, field_error='organization'):
        """
        if the relation is owned by a specific organization
        this object must be related to the same organization
        """
        # avoid exceptions caused by the relation not being set
        if not hasattr(self, rel):
            return
        rel = getattr(self, rel)
        if (
            rel
            and rel.organization_id
            and str(self.organization_id) != str(rel.organization_id)
        ):
            message = _(
                'Please ensure that the organization of this {object_label} '
                'and the organization of the related {related_object_label} match.'
            )
            message = message.format(
                object_label=self._meta.verbose_name,
                related_object_label=rel._meta.verbose_name,
            )
            raise ValidationError({field_error: message})

    def _validate_org_reverse_relation(self, rel_name, field_error='organization'):
        """
        prevents changing organization for existing objects
        which have relations specified by ``rel_name`` pointing to them,
        in order to prevent inconsistencies
        (relations belonging to different organizations)
        """
        # do nothing on new objects, because they
        # cannot have relations pointing to them
        if self._state.adding:
            return
        old_self = self.__class__.objects.get(pk=self.pk)
        old_org = old_self.organization
        # org hasn't been changed, everything ok
        if old_org == self.organization:
            return
        rel = getattr(self, rel_name)
        count = rel.count()
        if count:
            rel_meta = rel.model._meta
            related_label = (
                rel_meta.verbose_name if count == 1 else rel_meta.verbose_name_plural
            )
            verb = _('is') if count == 1 else _('are')
            message = _(
                'The organization of this {object_label} cannot be changed '
                'because {0} {related_object_label} {verb} still '
                'related to it'.format(
                    count,
                    object_label=self._meta.verbose_name,
                    related_object_label=related_label,
                    verb=verb,
                )
            )
            raise ValidationError({field_error: message})


class OrgMixin(ValidateOrgMixin, models.Model):
    """
    - adds a ``ForeignKey`` field to the ``Organization`` model
      (the relation cannot be NULL)
    - implements ``_validate_org_relation`` method
    """

    organization = models.ForeignKey(
        get_model_name('openwisp_users', 'Organization'),
        verbose_name=_('organization'),
        on_delete=models.CASCADE,
    )

    class Meta:
        abstract = True


class OrganizationDbMixin:
    @cached_property
    def db(self):
        user = self.request.user
        if user.is_authenticated:
            return get_db_for_user(user)
        return 'default'

    def get_queryset(self):
        return super().get_queryset().using(self.db)
    
    def get_object(self, queryset=None):
        if queryset is None:
            queryset = self.get_queryset()
        return super().get_object(queryset=queryset)


#   db.py file
import environ
from pathlib import Path

BASE_DIR = Path(__file__).resolve(strict=True).parent

env = environ.Env()
env.read_env() # read the .env file
# environ.Env.read_env() # read the .env file

# DATABASES for different organisations
DATABASES = {
    'default': {
        'ENGINE': env('POSTGRES_ENGINE'),
        'NAME': env('DEFAULT_DB_NAME'),
        'USER': env('DEFAULT_DB_USER'),
        'PASSWORD': env('DEFAULT_DB_PASSWORD'),
        'HOST': env('DEFAULT_DB_HOST'),
        'PORT': env('DEFAULT_DB_PORT'),
    },
    'gies': {
        'ENGINE': env('POSTGRES_ENGINE'),
        'NAME': env('GIES_DB_NAME'),
        'USER': env('GIES_DB_USER'),
        'PASSWORD': env('GIES_DB_PASSWORD'),
        'HOST': env('GIES_DB_HOST'),
        'PORT': env('GIES_DB_PORT'),
    },
    'gigmeg': {
        'ENGINE': env('POSTGRES_ENGINE'),
        'NAME': env('GIGMEG_DB_NAME'),
        'USER': env('GIGMEG_DB_USER'),
        'PASSWORD': env('GIGMEG_DB_PASSWORD'),
        'HOST': env('GIGMEG_DB_HOST'),
        'PORT': env('GIGMEG_DB_PORT'),
    },
}


#   models.py file
class Organization(models.Model):
    name = models.CharField(_("name"), max_length=100)
    slug = models.CharField(_("slug"), max_length=100)


class AbstractPlan(OrgMixin, BaseMixin, OrderedModel):
    """
    Single plan defined in the system. A plan can customized (referred to user) which means
    that only this user can purchase this plan and have it selected.

    Plan also can be visible and available. Plan is displayed on the list of currently available plans
    for user if it is visible. User cannot change plan to a plan that is not visible. Available means
    that user can buy a plan. If plan is not visible but still available it means that user which
    is using this plan already will be able to extend this plan again. If plan is not visible and not
    available, he will be forced then to change plan next time he extends an account.
    """

    name = models.CharField(_("name"), max_length=100)
    description = models.TextField(_("description"), blank=True)
    default = models.BooleanField(
        help_text=_('Both "Unknown" and "No" means that the plan is not default'),
        default=None,
        db_index=True,
        unique=True,
        null=True,
    )
    available = models.BooleanField(
        _("available"),
        default=False,
        db_index=True,
        help_text=_("Is still available for purchase"),
    )
    visible = models.BooleanField(
        _("visible"),
        default=True,
        db_index=True,
        help_text=_("Is visible in current offer"),
    )
    customized = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        null=True,
        blank=True,
        verbose_name=_("customized"),
        on_delete=models.CASCADE,
    )
    quotas = models.ManyToManyField("Quota", through="PlanQuota")
    url = models.URLField(
        max_length=200,
        blank=True,
        help_text=_(
            "Optional link to page with more information (for clickable pricing table headers)"
        ),
    )
    BANDWIDTH, DATA = 'Bandwidth', 'Data'
    plan_class_choices = (
        (BANDWIDTH, _('Bandwidth')),
        (DATA, _('Data')),
    )
    plan_class = models.CharField(_("Plan Class"), max_length=16, default=DATA, choices=plan_class_choices) 
    PREPAID, POSTPAID = 'Prepaid', 'Postpaid'
    plan_type_choices = (
        (PREPAID, _('Prepaid')),
        (POSTPAID, _('Postpaid')),
    )
    plan_type = models.CharField(_("Plan Type"), max_length=16, default=PREPAID, choices=plan_type_choices)
    plan_setup_cost = models.DecimalField(_('Plan Setup Cost'), max_digits=7, decimal_places=2, db_index=True,
        blank=True,
        null=True,
        )
    rating = models.FloatField(_('Rating'), blank=True, null=True, editable=False) 
    radius_group = models.ForeignKey('openwisp_radius.RadiusGroup', on_delete=models.CASCADE,
        blank=True,
        null=True,
        verbose_name=_('RADIUS group:'), related_name="plan_radius",
        )
    temp_radius_group = models.ForeignKey('openwisp_radius.RadiusGroup', on_delete=models.CASCADE,
        blank=True,
        null=True,
        verbose_name=_('Temporary RADIUS group:'), related_name="plan_temp_radius",
        )

    class Meta:
        abstract = True
        ordering = ("order",)
        verbose_name = _("Plan")
        verbose_name_plural = _("Plans")

    @classmethod
    def get_default_plan(cls):
        try:
            return_value = cls.objects.get(default=True)
        except cls.DoesNotExist:
            return_value = None
        return return_value

    @classmethod
    def get_current_plan(cls, user):
        """Get current plan for user. If userplan is expired, get default plan"""
        if (
            not user
            or user.is_anonymous
            or not hasattr(user, "userplan")
            or user.userplan.is_expired()
        ):
            default_plan = cls.get_default_plan()
            if default_plan is None or not default_plan.is_free():
                raise ValidationError(_("User plan has expired"))
            return default_plan
        return user.userplan.plan

    def __str__(self):
        return self.name

    def get_quota_dict(self):
        return dict(self.planquota_set.values_list("quota__codename", "value"))

    def is_free(self):
        return self.planpricing_set.count() == 0

    is_free.boolean = True


class AbstractBillingInfo(OrgMixin, BaseMixin, models.Model):
    """
    Stores customer billing data needed to issue an invoice
    """

    user = models.OneToOneField(
        settings.AUTH_USER_MODEL, verbose_name=_("user"), on_delete=models.CASCADE
    )
    tax_number = models.CharField(
        _("VAT ID"), max_length=200, blank=True, db_index=True
    )
    name = models.CharField(_("name"), max_length=200, db_index=True)
    street = models.CharField(_("street"), max_length=200)
    zipcode = models.CharField(_("zip code"), max_length=200)
    city = models.CharField(_("city"), max_length=200)
    country = CountryField(_("country"))
    shipping_name = models.CharField(
        _("name (shipping)"), max_length=200, blank=True, help_text=_("optional")
    )
    shipping_street = models.CharField(
        _("street (shipping)"), max_length=200, blank=True, help_text=_("optional")
    )
    shipping_zipcode = models.CharField(
        _("zip code (shipping)"), max_length=200, blank=True, help_text=_("optional")
    )
    shipping_city = models.CharField(
        _("city (shipping)"), max_length=200, blank=True, help_text=_("optional")
    )

    class Meta:
        abstract = True
        verbose_name = _("Billing info")
        verbose_name_plural = _("Billing infos")

    @staticmethod
    def get_full_tax_number(tax_number, country):
        number = tax_number
        if tax_number.startswith(country):
            number = tax_number[len(country) :]
        return country_code_transform(country) + number

    @staticmethod
    def clean_tax_number(tax_number, country):
        tax_number = re.sub(r"[^A-Z0-9]", "", tax_number.upper())

        country_str = tax_number[: len(country)]
        if country_str == country_code_transform(country):
            country = country_code_transform(country)

        if country_str.isalpha() and country_str != country:
            raise ValidationError(
                _("VAT ID country code doesn't corespond with country")
            )

        if tax_number and country:
            if country.lower() in stdnum.eu.vat.MEMBER_STATES:
                full_number = (
                    AbstractBillingInfo.get_concrete_model().get_full_tax_number(
                        tax_number, country
                    )
                )
                try:
                    return stdnum.eu.vat.validate(full_number)
                except stdnum.exceptions.ValidationError as e:
                    raise ValidationError(_(f"VAT ID is not correct: {e.message}"))

            return tax_number
        else:
            return ""


class AbstractUserPlan(BaseMixin, models.Model):
    """
    Currently selected plan for user account.
    """

    user = models.OneToOneField(
        settings.AUTH_USER_MODEL, verbose_name=_("user"), on_delete=models.CASCADE
    )
    plan = models.ForeignKey("Plan", verbose_name=_("plan"), on_delete=models.CASCADE)
    expire = models.DateField(
        _("expire"), default=None, blank=True, null=True, db_index=True
    )
    active = models.BooleanField(_("active"), default=True, db_index=True)

    class Meta:
        abstract = True
        verbose_name = _("User plan")
        verbose_name_plural = _("Users plans")

    def __str__(self):
        return "%s [%s]" % (self.user, self.plan)

    def is_active(self):
        return self.active

    def is_expired(self):
        if self.expire is None:
            return False
        else:
            return self.expire < date.today()

    def days_left(self):
        if self.expire is None:
            return None
        else:
            return (self.expire - date.today()).days

    def clean_activation(self):
        errors = plan_validation(self.user)
        if not errors["required_to_activate"]:
            plan_validation(self.user, on_activation=True)
            self.activate()
        else:
            self.deactivate()
        return errors

    def activate(self):
        if not self.active:
            self.active = True
            self.save()
            account_activated.send(sender=self, user=self.user)

    def deactivate(self):
        if self.active:
            self.active = False
            self.save()
            account_deactivated.send(sender=self, user=self.user)

    def initialize(self):
        """
        Set up user plan for first use
        """
        if not self.is_active():
            # Plans without pricings don't need to expire
            if self.expire is None and self.plan.planpricing_set.count():
                self.expire = now() + timedelta(
                    days=getattr(settings, "PLANS_DEFAULT_GRACE_PERIOD", 30)
                )
            self.activate()  # this will call self.save()

    def get_plan_extended_from(self, plan):
        if plan.is_free():
            return None
        if not self.is_expired() and self.expire is not None and self.plan == plan:
            return self.expire
        return date.today()

    def has_automatic_renewal(self):
        return (
            hasattr(self, "recurring")
            and self.recurring.has_automatic_renewal
            and self.recurring.token_verified
        )

    def get_plan_extended_until(self, plan, pricing):
        if plan.is_free():
            return None
        if pricing is None:
            return self.expire
        return self.get_plan_extended_from(plan) + timedelta(days=pricing.period)

    def plan_autorenew_at(self):
        """
        Helper function which calculates when the plan autorenewal will occur
        """
        if self.expire:
            plans_autorenew_before_days = getattr(
                settings, "PLANS_AUTORENEW_BEFORE_DAYS", 0
            )
            plans_autorenew_before_hours = getattr(
                settings, "PLANS_AUTORENEW_BEFORE_HOURS", 0
            )
            return self.expire - timedelta(
                days=plans_autorenew_before_days, hours=plans_autorenew_before_hours
            )

    def set_plan_renewal(self, order, has_automatic_renewal=True, **kwargs):
        """
        Creates or updates plan renewal information for this userplan with given order
        """
        if not hasattr(self, "recurring"):
            self.recurring = AbstractRecurringUserPlan.get_concrete_model()()

        # Erase values of all fields
        # We don't want to mix the old and new values
        self.recurring.set_all_fields_default()

        # Set new values
        self.recurring.user_plan = self
        self.recurring.pricing = order.pricing
        self.recurring.amount = order.amount
        self.recurring.tax = order.tax
        self.recurring.currency = order.currency
        self.recurring.has_automatic_renewal = has_automatic_renewal
        for k, v in kwargs.items():
            setattr(self.recurring, k, v)
        self.recurring.save()
        return self.recurring

    def extend_account(self, plan, pricing):
        """
        Manages extending account after plan or pricing order
        :param plan:
        :param pricing: if pricing is None then account will be only upgraded
        :return:
        """

        status = False  # flag; if extending account was successful?
        expire = self.get_plan_extended_until(plan, pricing)
        if pricing is None:
            # Process a plan change request (downgrade or upgrade)
            # No account activation or extending at this point
            self.plan = plan

            if self.expire is not None and not plan.planpricing_set.count():
                # Assume no expiry date for plans without pricing.
                self.expire = None

            self.save()
            account_change_plan.send(sender=self, user=self.user)
            if getattr(settings, "PLANS_SEND_EMAILS_PLAN_CHANGED", True):
                mail_context = {"user": self.user, "userplan": self, "plan": plan}
                send_template_email(
                    [self.user.email],
                    "mail/change_plan_title.txt",
                    "mail/change_plan_body.txt",
                    mail_context,
                    get_user_language(self.user),
                )
            accounts_logger.info(
                "Account '%s' [id=%d] plan changed to '%s' [id=%d]"
                % (self.user, self.user.pk, plan, plan.pk)
            )
            status = True
        else:
            # Processing standard account extending procedure
            if self.plan == plan:
                status = True
            else:
                # This should not ever happen (as this case should be managed by plan change request)
                # but just in case we consider a case when user has a different plan
                if not self.plan.is_free() and self.expire is None:
                    status = True
                elif not self.plan.is_free() and self.expire > date.today():
                    status = False
                    accounts_logger.warning(
                        "Account '%s' [id=%d] plan NOT changed to '%s' [id=%d]"
                        % (self.user, self.user.pk, plan, plan.pk)
                    )
                else:
                    status = True
                    account_change_plan.send(sender=self, user=self.user)
                    self.plan = plan

            if status:
                self.expire = expire
                self.save()
                accounts_logger.info(
                    "Account '%s' [id=%d] has been extended by %d days using plan '%s' [id=%d]"
                    % (self.user, self.user.pk, pricing.period, plan, plan.pk)
                )
                if getattr(settings, "PLANS_SEND_EMAILS_PLAN_EXTENDED", True):
                    mail_context = {
                        "user": self.user,
                        "userplan": self,
                        "plan": plan,
                        "pricing": pricing,
                    }
                    send_template_email(
                        [self.user.email],
                        "mail/extend_account_title.txt",
                        "mail/extend_account_body.txt",
                        mail_context,
                        get_user_language(self.user),
                    )

        if status:
            self.clean_activation()

        return status

    def expire_account(self):
        """manages account expiration"""

        self.deactivate()

        accounts_logger.info(
            "Account '%s' [id=%d] has expired" % (self.user, self.user.pk)
        )

        mail_context = {"user": self.user, "userplan": self}
        send_template_email(
            [self.user.email],
            "mail/expired_account_title.txt",
            "mail/expired_account_body.txt",
            mail_context,
            get_user_language(self.user),
        )

        account_expired.send(sender=self, user=self.user)

    def remind_expire_soon(self):
        """reminds about soon account expiration"""

        mail_context = {"user": self.user, "userplan": self, "days": self.days_left()}
        send_template_email(
            [self.user.email],
            "mail/remind_expire_title.txt",
            "mail/remind_expire_body.txt",
            mail_context,
            get_user_language(self.user),
        )

    @classmethod
    def create_for_user(cls, user):
        default_plan = AbstractPlan.get_concrete_model().get_default_plan()
        if default_plan is not None:
            UserPlan = AbstractUserPlan.get_concrete_model()
            return UserPlan.objects.create(
                user=user,
                plan=default_plan,
                active=False,
                expire=None,
            )

    @classmethod
    def create_for_users_without_plan(cls):
        userplans = get_user_model().objects.filter(userplan=None)
        for user in userplans:
            AbstractUserPlan.get_concrete_model().create_for_user(user)
        return userplans

    def get_current_plan(self):
        """Tiny helper, very usefull in templates"""
        return AbstractPlan.get_concrete_model().get_current_plan(self.user)
