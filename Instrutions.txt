Instuctions:
am going to share some django models and other codes for you to help me implement a tasks. You should wait until i tell you what to do with them.


You should wait until i tell you what to do with them.

class AbstractRadiusGroup(OrgMixin, TimeStampedEditableModel):
    """
    This is not part of the standard freeradius schema.
    It's added to facilitate the management of groups.
    """

    name = models.CharField(
        verbose_name=_('group name'), max_length=255, unique=True, db_index=True
    )
    description = models.CharField(
        verbose_name=_('description'), max_length=64, blank=True, null=True
    )
    _DEFAULT_HELP_TEXT = (
        'The default group is automatically assigned to new users; '
        'changing the default group has only effect on new users '
        '(existing users will keep being members of their current group)'
    )
    default = models.BooleanField(
        verbose_name=_('is default?'), help_text=_(_DEFAULT_HELP_TEXT), default=False
    )

    class Meta:
        verbose_name = _('group')
        verbose_name_plural = _('groups')
        abstract = True

    def __str__(self):
        return self.name

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self._initial_default = self.default

    def clean(self):
        self.check_default()
        if not hasattr(self, 'organization'):
            return
        if not self.name.startswith(f'{self.organization.slug}-'):
            self.name = f'{self.organization.slug}-{self.name}'

    def save(self, *args, **kwargs):
        result = super().save(*args, **kwargs)
        if self.default:
            self.set_default()
        # sync all related records
        if not self._state.adding:
            self.radiusgroupcheck_set.update(groupname=self.name)
            self.radiusgroupreply_set.update(groupname=self.name)
            self.radiususergroup_set.update(groupname=self.name)
        return result

    _DEFAULT_VALIDATION_ERROR = _(
        'There must be at least one default group present in '
        'the system. To change the default group, simply set '
        'as default the group you want to make the new default.'
    )
    _DEFAULT_PROTECTED_ERROR = _('The default group cannot be deleted')

    def delete(self, *args, **kwargs):
        if self.default:
            raise ProtectedError(self._DEFAULT_PROTECTED_ERROR, self)
        return super().delete(*args, **kwargs)

    def set_default(self):
        """
        ensures there's only 1 default group
        (logic overridable via custom models)
        """
        queryset = self.get_default_queryset()
        if queryset.exists():
            queryset.update(default=False)

    def check_default(self):
        """
        ensures the default group cannot be undefaulted
        (logic overridable via custom models)
        """
        if not self.default and self._initial_default:
            raise ValidationError({'default': self._DEFAULT_VALIDATION_ERROR})

    def get_default_queryset(self):
        """
        looks for default groups excluding the current one
        overridable by openwisp-radius and other 3rd party apps
        """
        return self.__class__.objects.exclude(pk=self.pk).filter(
            default=True, organization_id=self.organization.pk
        )


class AbstractRadiusUserGroup(AutoGroupnameMixin, AutoUsernameMixin, TimeStampedEditableModel):
    username = models.CharField(
        verbose_name=_('username'),
        max_length=64,
        db_index=True,
        # blank values are forbidden with custom validation
        # because this field can left blank if the user
        # foreign key is filled (it will be auto-filled)
        blank=True,
    )
    groupname = models.CharField(
        verbose_name=_('group name'),
        max_length=64,
        # blank values are forbidden with custom validation
        # because this field can left blank if the group
        # foreign key is filled (it will be auto-filled)
        blank=True,
    )
    priority = models.IntegerField(verbose_name=_('priority'), default=1)
    # the foreign keys are not part of the standard freeradius schema,
    # these are added here to facilitate the synchronization of the
    # records which are related in different tables
    user = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.CASCADE, blank=True, null=True)
    group = models.ForeignKey( 'RadiusGroup', on_delete=models.CASCADE, blank=True, null=True)

    class Meta:
        db_table = 'radusergroup'
        verbose_name = _('user group')
        verbose_name_plural = _('user groups')
        unique_together = ('user', 'group')
        abstract = True

    def __str__(self):
        return str(self.username)


class AbstractRadiusGroupCheck(AutoGroupnameMixin, GroupAttributeValidationMixin, TimeStampedEditableModel):
    groupname = models.CharField(
        verbose_name=_('group name'),
        max_length=64,
        db_index=True,
        # blank values are forbidden with custom validation
        # because this field can left blank if the group
        # foreign key is filled (it will be auto-filled)
        blank=True,
    )
    attribute = models.CharField(verbose_name=_('attribute'), max_length=64)
    op = models.CharField(
        verbose_name=_('operator'),
        max_length=2,
        choices=RADOP_CHECK_TYPES,
        default=':=',
    )
    value = models.CharField(verbose_name=_('value'), max_length=253)
    # the foreign key is not part of the standard freeradius schema
    group = models.ForeignKey('RadiusGroup', on_delete=models.CASCADE, blank=True, null=True)


class AbstractQuota(OrgMixin, models.Model):
    '''
    Single countable or boolean property of system (limitation).
    '''
    MB, GB = 'MB', 'GB'
    quota_unit_choices = (
        (MB, _('MB')),
        (GB, _('GB')),
    )
    codename = models.CharField(_('codename'), max_length=MAX_LENGTH, unique=True, db_index=True)
    name     = models.CharField(_('name'), max_length=MAX_LENGTH)
    unit     = models.CharField(_('unit'), max_length=MAX_LENGTH, choices=quota_unit_choices, default=MB)
    description = models.TextField(_('description'), blank=True)
    is_boolean  = models.BooleanField(_('is boolean'), default=False)


class PlanQuotaManager(models.Manager):
    def get_queryset(self):
        return super().get_queryset().select_related('plan', 'quota')

class AbstractPlanQuota(OrgMixin, BaseMixin):
    plan  = models.ForeignKey('gmtisp_billing.Plan', on_delete=models.CASCADE)
    quota = models.ForeignKey('gmtisp_billing.Quota', on_delete=models.CASCADE)
    value = models.BigIntegerField(default=1, null=True, blank=True)

    objects = PlanQuotaManager()


class AbstractPlan(OrgMixin, BaseMixin):
    name = models.CharField(_('name'), max_length=MAX_LENGTH)
    slug = models.SlugField(
        _('slug'),
        max_length=MAX_LENGTH,           
        blank=False,
        editable=True,
        )
    description = models.CharField(_('description'), max_length=200, blank=True)
    available = models.BooleanField(
        _('Available:'),
        default=False,
        db_index=True,
        help_text=_('Is still available for purchase'),
    )
    visible = models.BooleanField(
        _('Visible:'),
        default=True,
        db_index=True,
        help_text=_('Is visible in current offer'),
    )
    requires_payment = models.BooleanField(
        _('Requires payment:'),
        default=False,
        db_index=True,
        help_text=_('If this flag is enabled, it means that you are required to perform a payment.'),
    )
    rollover_allowed = models.BooleanField(
        _('Allow rollover:'),
        default=True,
        db_index=True,
        help_text=_('Data purchasing now will be added to your remaining data, if you have any'),
    )
    quotas = models.ManyToManyField('gmtisp_billing.Quota', through='PlanQuota')
    plan_setup_cost = models.DecimalField(_('Plan Setup Cost'), max_digits=7, decimal_places=2, db_index=True,
        blank=True,
        null=True,
        )    
    radius_group = models.ForeignKey('openwisp_radius.RadiusGroup', on_delete=models.CASCADE,
        blank=True,
        null=True,
        verbose_name=_('RADIUS group:'), 
        related_name='plan_radius_group',
        )


class AbstractUserPlan(OrgMixin, BaseMixin):
    '''
    Currently selected plan for user account.
    '''
    user = models.OneToOneField(settings.AUTH_USER_MODEL, on_delete=models.CASCADE, verbose_name=_('user'))
    plan = models.ForeignKey('gmtisp_billing.Plan', on_delete=models.CASCADE, 
        verbose_name=_('plan'),
        help_text=_('Plan that user is subscribed to.'),
        )
    expire = models.DateField( _('expire'), default=None, blank=True, null=True, db_index=True)
    active = models.BooleanField(_('active'), default=True, db_index=True)
    
    class Meta:
        abstract = True
        verbose_name = _('User plan')
        verbose_name_plural = _('Users plans')
    
    def __str__(self):
        return f'{self.user.username} - {self.plan.name}'
    
    def get_absolute_url(self):
        return reverse('gmtisp_billing:userplan-details', kwargs={'pk': self.pk})

    def is_active(self):
        return self.active

    def is_expired(self):
        if self.expire is None:
            return False
        else:
            return self.expire < date.today()

    def days_left(self):
        if self.expire is None:
            return None
        else:
            return (self.expire - date.today()).days

    def clean_activation(self):
        errors = plan_validation(self.user)
        if not errors['required_to_activate']:
            plan_validation(self.user, on_activation=True)
            self.activate()
        else:
            self.deactivate()
        return errors

    def activate(self):
        if not self.active:
            self.active = True
            self.save()
            account_activated.send(sender=self, user=self.user)

    def deactivate(self):
        if self.active:
            self.active = False
            self.save()
            account_deactivated.send(sender=self, user=self.user)

    def initialize(self):
        '''
        Set up user plan for first use
        '''
        if not self.is_active():
            # Plans without pricings don't need to expire
            if self.expire is None and self.plan.planpricing_set.count():
                self.expire = now() + timedelta(
                    days=getattr(settings, 'PLANS_DEFAULT_GRACE_PERIOD', 30)
                )
            self.activate()  # this will call self.save()

    def get_plan_extended_from(self, plan):
        if plan.is_free():
            return None
        if not self.is_expired() and self.expire is not None and self.plan == plan:
            return self.expire
        return date.today()

    def has_automatic_renewal(self):
        return (
            hasattr(self, "recurring")
            and self.recurring.renewal_triggered_by
            != self.recurring.RENEWAL_TRIGGERED_BY.USER
            and self.recurring.token_verified
        )

    def get_plan_extended_until(self, plan, pricing):
        if plan.is_free():
            return None
        if pricing is None:
            return self.expire
        return self.get_plan_extended_from(plan) + timedelta(days=pricing.period)

    def plan_autorenew_at(self):
        '''
        Helper function which calculates when the plan autorenewal will occur
        '''
        if self.expire:
            plans_autorenew_before_days = getattr(
                settings, 'PLANS_AUTORENEW_BEFORE_DAYS', 0
            )
            plans_autorenew_before_hours = getattr(
                settings, 'PLANS_AUTORENEW_BEFORE_HOURS', 0
            )
            return self.expire - timedelta(
                days=plans_autorenew_before_days, hours=plans_autorenew_before_hours
            )

    def set_plan_renewal(self, order, has_automatic_renewal=None, renewal_triggered_by=None, **kwargs):
        '''
        Creates or updates plan renewal information for this userplan with given order
        '''
 
        if not hasattr(self, "recurring"):
            self.recurring = AbstractRecurringUserPlan.get_concrete_model()()

        if has_automatic_renewal is None and renewal_triggered_by is None:
            has_automatic_renewal = True
        if has_automatic_renewal is not None:
            warnings.warn(
                "has_automatic_renewal is deprecated. Use renewal_triggered_by instead.",
                DeprecationWarning,
            )
        if renewal_triggered_by is None:
            warnings.warn(
                "renewal_triggered_by=None is deprecated. "
                "Set an AbstractRecurringUserPlan.RENEWAL_TRIGGERED_BY instead.",
                DeprecationWarning,
            )
            renewal_triggered_by = (
                self.recurring.RENEWAL_TRIGGERED_BY.TASK
                if has_automatic_renewal
                else self.recurring.RENEWAL_TRIGGERED_BY.USER
            )

        # Erase values of all fields
        # We don't want to mix the old and new values
        self.recurring.set_all_fields_default()

        # Set new values
        self.recurring.user_plan = self
        self.recurring.pricing = order.pricing
        self.recurring.amount = order.amount
        self.recurring.tax = order.tax
        self.recurring.currency = order.currency
        self.recurring.renewal_triggered_by = renewal_triggered_by
        for k, v in kwargs.items():
            setattr(self.recurring, k, v)
        self.recurring.save()
        return self.recurring

    def extend_account(self, plan, pricing):
        '''
        Manages extending account after plan or pricing order
        '''
        status = False  # flag; if extending account was successful?
        expire = self.get_plan_extended_until(plan, pricing)
        if pricing is None:
            # Process a plan change request (downgrade or upgrade)
            # No account activation or extending at this point
            self.plan = plan

            if self.expire is not None and not plan.planpricing_set.count():
                # Assume no expiry date for plans without pricing.
                self.expire = None

            self.save()
            account_change_plan.send(sender=self, user=self.user)
            if getattr(settings, 'PLANS_SEND_EMAILS_PLAN_CHANGED', True):
                mail_context = {'user': self.user, 'userplan': self, 'plan': plan}
                send_template_email(
                    [self.user.email],
                    'gmtisp_billing/mail/change_plan_title.txt',
                    'gmtisp_billing/mail/change_plan_body.txt',
                    mail_context,
                    get_user_language(self.user),
                )
            accounts_logger.info(
                "Account '%s' [id=%d] plan changed to '%s' [id=%d]"
                % (self.user, self.user.pk, plan, plan.pk)
            )
            status = True
        else:
            # Processing standard account extending procedure
            if self.plan == plan:
                status = True
            else:
                # This should not ever happen (as this case should be managed by plan change request)
                # but just in case we consider a case when user has a different plan
                if not self.plan.is_free() and self.expire is None:
                    status = True
                elif not self.plan.is_free() and self.expire > date.today():
                    status = False
                    accounts_logger.warning(
                        "Account '%s' [id=%d] plan NOT changed to '%s' [id=%d]"
                        % (self.user, self.user.pk, plan, plan.pk)
                    )
                else:
                    status = True
                    account_change_plan.send(sender=self, user=self.user)
                    self.plan = plan

            if status:
                self.expire = expire
                self.save()
                accounts_logger.info(
                    "Account '%s' [id=%d] has been extended by %d days using plan '%s' [id=%d]"
                    % (self.user, self.user.pk, pricing.period, plan, plan.pk)
                )
                if getattr(settings, 'PLANS_SEND_EMAILS_PLAN_EXTENDED', True):
                    mail_context = {
                        'user': self.user,
                        'userplan': self,
                        'plan': plan,
                        'pricing': pricing,
                    }
                    send_template_email(
                        [self.user.email],
                        'gmtisp_billing/mail/extend_account_title.txt',
                        'gmtisp_billing/mail/extend_account_body.txt',
                        mail_context,
                        get_user_language(self.user),
                    )

        if status:
            self.clean_activation()

        return status

    def expire_account(self):
        '''manages account expiration'''

        self.deactivate()

        accounts_logger.info(
            "Account '%s' [id=%d] has expired" % (self.user, self.user.pk)
        )

        mail_context = {'user': self.user, 'userplan': self}
        send_template_email(
            [self.user.email],
            'gmtisp_billing/mail/expired_account_title.txt',
            'gmtisp_billing/mail/expired_account_body.txt',
            mail_context,
            get_user_language(self.user),
        )

        account_expired.send(sender=self, user=self.user)

    def remind_expire_soon(self):
        '''reminds about soon account expiration'''

        mail_context = {'user': self.user, 'userplan': self, 'days': self.days_left()}
        send_template_email(
            [self.user.email],
            'gmtisp_billing/mail/remind_expire_title.txt',
            'gmtisp_billing/mail/remind_expire_body.txt',
            mail_context,
            get_user_language(self.user),
        )

    @classmethod
    def create_for_user(cls, user):
        default_plan = AbstractPlan.get_concrete_model().get_default_plan()
        if default_plan is not None:
            UserPlan = AbstractUserPlan.get_concrete_model()
            return UserPlan.objects.create(
                user=user,
                plan=default_plan,
                active=False,
                expire=None,
            )

    @classmethod
    def create_for_users_without_plan(cls):
        userplans = get_user_model().objects.filter(userplan=None)
        for user in userplans:
            AbstractUserPlan.get_concrete_model().create_for_user(user)
        return userplans

    def get_current_plan(self):
        '''Tiny helper, very usefull in templates'''
        return AbstractPlan.get_concrete_model().get_current_plan(self.user)







Todo:
1. How to validate if a plan's quota for data traffic has reached its limit

Note that,
1. a plan is associated with 'class RadiusGroup' using a ForeignKey, which checks the RadiusGroup a plan belongs to and it limitations, very important.
2. user and plan are associated using class AbstractUserPlan
3. AbstractPlanQuota is used to associate plan, quota
4. it's necessary to use the codes/models i have shared with you from the beginning

# context_processors.py
UserPlan = AbstractUserPlan.get_concrete_model()

def account_status(request):
    if hasattr(request, "user") and request.user.is_authenticated:
        try:
            return {
                "ACCOUNT_EXPIRED": request.user.userplan.is_expired(),
                "ACCOUNT_NOT_ACTIVE": (
                    not request.user.userplan.is_active()
                    and not request.user.userplan.is_expired()
                ),
                "EXPIRE_IN_DAYS": request.user.userplan.days_left(),
                "EXTEND_URL": reverse("current_plan"),
                "ACTIVATE_URL": reverse("account_activation"),
            }
        except UserPlan.DoesNotExist:
            pass
    return {}

# importer.py
def import_name(name):
    """import module given by str or pass the module if it is not str"""
    if isinstance(name, str):
        components = name.split(".")
        mod = __import__(
            ".".join(components[0:-1]), globals(), locals(), [components[-1]]
        )
        return getattr(mod, components[-1])
    else:
        return name

# listners.py
from .signals import activate_user_plan, order_completed

@receiver(post_save, sender=Order)
def create_proforma_invoice(sender, instance, created, **kwargs):
    """
    For every Order if there are defined billing_data creates invoice proforma,
    which is an order confirmation document
    """
    if created:
        Invoice.create(instance, Invoice.INVOICE_TYPES["PROFORMA"])

@receiver(order_completed)
def create_invoice(sender, **kwargs):
    Invoice.create(sender, Invoice.INVOICE_TYPES["INVOICE"])

@receiver(post_save, sender=Invoice)
def send_invoice_by_email(sender, instance, created, **kwargs):
    if created:
        instance.send_invoice_by_email()

@receiver(post_save, sender=User)
def set_default_user_plan(sender, instance, created, **kwargs):
    """
    Creates default plan for the new user but also extending an account for default grace period.
    """
    if created:
        UserPlan.create_for_user(instance)
# Hook to django-registration to initialize plan automatically after user has confirm account

@receiver(activate_user_plan)
def initialize_plan_generic(sender, user, **kwargs):
    try:
        user.userplan.initialize()
    except UserPlan.DoesNotExist:
        return


# quota.py
def get_user_quota(user):
    """
    Tiny helper for getting quota dict for user
    If user has expired plan, return default plan or None
    """
    from .base.models import AbstractPlan

    Plan = AbstractPlan.get_concrete_model()
    plan = Plan.get_current_plan(user)
    return plan.get_quota_dict()


# signnals.py
from django.dispatch import Signal

order_started = Signal()
order_started.__doc__ = """
Sent after order was started (awaiting payment)
"""

order_completed = Signal()
order_completed.__doc__ = """
Sent after order was completed (payment accepted, account extended)
"""

user_language = Signal()
user_language.__doc__ = """
Sent to receive information about language for user account

sends arguments: 'user', 'language'
"""

account_automatic_renewal = Signal()
account_automatic_renewal.__doc__ = """
Try to renew the account automatically.
Should renew the user's UserPlan by recurring payments. If this succeeds, the plan should be extended.

sends arguments: 'user'
"""

account_expired = Signal()
account_expired.__doc__ = """
Sent on account expiration.
This signal is send regardless ``account_deactivated``
it only means that account has expired due to plan expire date limit.

sends arguments: 'user'
"""

account_deactivated = Signal()
account_deactivated.__doc__ = """
Sent on account deactivation, account is not operational (it could be not expired, but does not meet quota limits).

sends arguments: 'user'
"""

account_activated = Signal()
account_activated.__doc__ = """
Sent on account activation, account is now fully operational.

sends arguments: 'user'
"""
account_change_plan = Signal()
account_change_plan.__doc__ = """
Sent on account when plan was changed after order completion

sends arguments: 'user'
"""

activate_user_plan = Signal()
activate_user_plan.__doc__ = """
This signal should be called when user has succesfully registered (e.g. he activated account via e-mail activation).
If you are using django-registration there is no need to call this signal.

sends arguments: 'user'
"""
# Signal sent whenever status is changed for a Payment. This usually happens
# when a transaction is either accepted or rejected.
status_changed = Signal()

# tasks.py
def get_active_plans():
    return (
        User.objects.select_related("userplan")
        .filter(userplan__active=True)
        .exclude(userplan__expire=None)
    )


def autorenew_account(providers=None):
    logger.info("Started automatic account renewal")
    PLANS_AUTORENEW_BEFORE_DAYS = getattr(settings, "PLANS_AUTORENEW_BEFORE_DAYS", 0)
    PLANS_AUTORENEW_BEFORE_HOURS = getattr(settings, "PLANS_AUTORENEW_BEFORE_HOURS", 0)

    accounts_for_renewal = get_active_plans().filter(
        userplan__recurring__renewal_triggered_by=AbstractRecurringUserPlan.RENEWAL_TRIGGERED_BY.TASK,
        userplan__recurring__token_verified=True,
        userplan__expire__lt=datetime.date.today()
        + datetime.timedelta(
            days=PLANS_AUTORENEW_BEFORE_DAYS, hours=PLANS_AUTORENEW_BEFORE_HOURS
        ),
    )

    if providers:
        accounts_for_renewal = accounts_for_renewal.filter(
            userplan__recurring__payment_provider__in=providers
        )

    logger.info(f"{len(accounts_for_renewal)} accounts to be renewed.")

    for user in accounts_for_renewal.all():
        account_automatic_renewal.send(sender=None, user=user)
    return accounts_for_renewal


def expire_account():
    logger.info("Started account expiration")

    expired_accounts = get_active_plans().filter(
        userplan__expire__lt=datetime.date.today()
    )

    for user in expired_accounts.all():
        user.userplan.expire_account()

    notifications_days_before = getattr(settings, "PLANS_EXPIRATION_REMIND", [])

    if notifications_days_before:
        days = map(
            lambda x: datetime.date.today() + datetime.timedelta(days=x),
            notifications_days_before,
        )
        for user in User.objects.select_related("userplan").filter(
            userplan__active=True, userplan__expire__in=days
        ):
            user.userplan.remind_expire_soon()

# validators.py
class QuotaValidator(object):
    """
    Base class for all Quota validators needed for account activation
    """
    required_to_activate = True
    default_quota_value = None

    @property
    def code(self):
        raise ImproperlyConfigured("Quota code name is not provided for validator")

    def get_quota_value(self, user, quota_dict=None):
        """
        Returns quota value for a given user
        """
        if quota_dict is None:
            quota_dict = get_user_quota(user)

        return quota_dict.get(self.code, self.default_quota_value)

    def get_error_message(self, quota_value, **kwargs):
        return "Plan validation error"

    def get_error_params(self, quota_value, **kwargs):
        return {
            "quota": quota_value,
            "validator_codename": self.code,
        }

    def __call__(self, user, quota_dict=None, **kwargs):
        """
        Performs validation of quota limit for a user account
        """
        raise NotImplementedError("Please implement specific QuotaValidator")

    def on_activation(self, user, quota_dict=None, **kwargs):
        """
        Hook for any action that validator needs to do while successful activation of the plan
        Most useful for validators not required to activate, e.g. some "option" is turned ON for user
        but when user downgrade plan this option should be turned OFF automatically rather than
        stops account activation
        """
        pass

class ModelCountValidator(QuotaValidator):
    """
    Validator that checks if there is no more than quota number of objects given model
    """

    @property
    def model(self):
        raise ImproperlyConfigured("ModelCountValidator requires model name")

    def get_queryset(self, user):
        return self.model.objects.all()

    def get_error_message(self, quota_value, **kwargs):
        return _(
            "Limit of %(model_name_plural)s exceeded. The limit is %(quota)s items."
        )

    def get_error_params(self, quota_value, total_count, **kwargs):
        return {
            "quota": quota_value,
            "model_name_plural": self.model._meta.verbose_name_plural.title().lower(),
            "validator_codename": self.code,
            "total_count": total_count,
        }

    def __call__(self, user, quota_dict=None, **kwargs):
        quota = self.get_quota_value(user, quota_dict)
        total_count = self.get_queryset(user).count() + kwargs.get("add", 0)
        if quota is not None and total_count > quota:
            raise ValidationError(
                message=self.get_error_message(quota),
                params=self.get_error_params(quota, total_count),
            )


class ModelAttributeValidator(ModelCountValidator):
    """
    Validator checks if every obj.attribute value for a given model satisfy condition
    provided in check_attribute_value() method.

    .. warning::
        ModelAttributeValidator requires `get_absolute_url()` method on provided model.
    """

    @property
    def attribute(self):
        raise ImproperlyConfigured(
            "ModelAttributeValidator requires defining attribute name"
        )

    def check_attribute_value(self, attribute_value, quota_value):
        # default is to value is <= limit
        return attribute_value <= quota_value

    def get_error_message(self, quota_value, **kwargs):
        return _("Following %(model_name_plural)s are not in limits: %(objects)s")

    def get_error_params(self, quota_value, total_count, **kwargs):
        return {
            "quota": quota_value,
            "validator_codename": self.code,
            "model_name_plural": self.model._meta.verbose_name_plural.title().lower(),
            "objects": ", ".join(
                map(
                    lambda o: '<a href="%s">%s</a>' % (o.get_absolute_url(), six.u(o)),
                    kwargs["not_valid_objects"],
                )
            ),
        }

    def __call__(self, user, quota_dict=None, **kwargs):
        quota_value = self.get_quota_value(user, quota_dict)
        not_valid_objects = []
        if quota_value is not None:
            for obj in self.get_queryset(user):
                if not self.check_attribute_value(
                    getattr(obj, self.attribute), quota_value
                ):
                    not_valid_objects.append(obj)
        if not_valid_objects:
            raise ValidationError(
                self.get_error_message(
                    quota_value, not_valid_objects=not_valid_objects
                ),
                self.get_error_params(quota_value, not_valid_objects=not_valid_objects),
            )

def plan_validation(user, plan=None, on_activation=False):
    """
    Validates validator that represents quotas in a given system
    :param user:
    :param plan:
    :return:
    """
    if plan is None:
        # if plan is not given, the default is to use current plan of the user
        plan = user.userplan.plan
    quota_dict = plan.get_quota_dict()
    validators = getattr(settings, "PLANS_VALIDATORS", {})
    validators = import_name(validators)
    errors = {
        "required_to_activate": [],
        "other": [],
    }

    for quota in validators:
        validator = import_name(validators[quota])

        if on_activation:
            validator.on_activation(user, quota_dict)
        else:
            try:
                validator(user, quota_dict)
            except ValidationError as e:
                if validator.required_to_activate:
                    errors["required_to_activate"].extend(e.messages)
                else:
                    errors["other"].extend(e.messages)
    return errors
